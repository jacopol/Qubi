Extensions Input:
- allow gates xor, ite  (easy)
- allow non-prefix qcir (semantics?)
- allow free variables  (doable)

Preprocessing:
- eliminate pure positive/negative literals
- early quantification (non-prenex): push quantifiers inside
- print/parse non-prenex (?)
- transform back to prenex (partially or completely)

Solving:
- use parallel disjunction/conjunction

Improvements:
- statistics: timing
- statistics: keep and print peak BDD
- statistics: compute peak BDD during large and/or
- take care of removed variables in returned example
- print original gate name with -k (extend permutation)

Refactor:
- refactor: Solver could be an abstract class / interface
- refactor: Try other BDD packages (or Sylvan ZDD)
- refactor: enforce bdd-manager discipline (singleton pattern?)

Suggestions for Sylvan:
- simplify initialisation (at least for non-lace use)
- vector<bool> PickOneCube(vector<uint32_t>variables) 
- map<int,bool> PickOneCube(BDDset variables)
- resolve Bdd vs Cube vs BddSet
- vector<bool> vs vector<uint_8>
- bool 0,1 versus enum {0,1,2} (don't care values)
- VariablesCube: also when not sorted!
- sylvan_quite vs quitPackage (in example)
- why is Sylvan a class? Should be sylvan_mgr? Singleton pattern?
- ask lace for number of workers? (in case initialized with 0)
- make install target is broken on trolando, works on utwente-fmt

Challenges:
- Breakthrough: all solved
- Connect4: all solved
- BSP: all solved

- Domineering/5x6_11_bnwib.qcir
- HTTT/4x4_13_skinny_bwnib.qcir
- EP/8x8_11_e-8-1_p-2-3_bwnib.qcir
- EP-dual/
- Hex/hein_02_5x5-11_bwnib.qcir
- Hex/hein_02_5x5-13_bwnib.qcir
- Hex/hein_10_5x5-11_bwnib.qcir
- Hex/hein_10_5x5-13_bwnib.qcir
- Hex/hein_11_5x5-11_bwnib.qcir
- Hex/hein_15_5x5-15_bwnib.qcir

- Benchmarks/Hein/SN_N/hein_02_5x5-11_cp.qcir (matrix)
- Benchmarks/Hein/SN_N/hein_10_5x5-11_cp.qcir (matrix)